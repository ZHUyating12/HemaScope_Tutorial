[["index.html", "HemaScope Tutorial 1 Introduction", " HemaScope Tutorial Zhenyi Wang and Yuxin Miao 2024-07-19 1 Introduction HemaScope is a specialized bioinformatics toolkit designed for analyzing both single-cell and spatial transcriptome sequencing data from hematopoietic cells, including myeloid and lymphoid lineages. We have developed an R package named HemaScopeR, a Shiny interface named HemaScopeShiny, and a cloud platform named HemaScopeCloud. This tutorial introduces how to install and use the R package and Shiny interface, as well as how to access and operate the cloud platform. "],["installation.html", "2 Installation 2.1 Install R and python 2.2 Install required R-packages 2.3 Install required Python-packages 2.4 Install HemaScopeR", " 2 Installation 2.1 Install R and python Create a new conda environment,install R 4.3.3 and python 3.11.4 conda create --name HemaScopeR_env conda activate HemaScopeR_env conda install R-base=4.3.3 conda install python=3.11.4 2.2 Install required R-packages install high-priority packages R: install.packages(&quot;BiocManager&quot;,version=&quot;1.30.23&quot;) BiocManager::install(&quot;ComplexHeatmap&quot;) BiocManager::install(&quot;scmap&quot;) Conda: conda config --add channels bioconda conda install -c conda-forge r-devtools=2.4.5 conda install -c conda-forge r-Seurat=4.3.0.1 conda install -c conda-forge r-Rfast2=0.1.5.1 conda install -c conda-forge r-hdf5r=1.3.10 conda install pwwang::r-seuratwrappers install required packages from cran remotes::install_version(&quot;shiny&quot;, version = &quot;1.7.5&quot;) remotes::install_version(&quot;textshaping&quot;, version = &quot;0.3.6&quot;) remotes::install_version(&quot;shinyjs&quot;, version = &quot;2.1.0&quot;) remotes::install_version(&quot;phateR&quot;, version = &quot;1.0.7&quot;) remotes::install_version(&quot;plyr&quot;, version = &quot;1.8.8&quot;) remotes::install_version(&quot;dplyr&quot;, version = &quot;1.1.2&quot;) remotes::install_version(&quot;ggpubr&quot;, version = &quot;0.6.0&quot;) remotes::install_version(&quot;viridis&quot;, version = &quot;0.6.4&quot;) remotes::install_version(&quot;pheatmap&quot;, version = &quot;1.0.12&quot;) remotes::install_version(&quot;feather&quot;, version = &quot;0.3.5&quot;) remotes::install_version(&quot;foreach&quot;, version = &quot;1.5.2&quot;) remotes::install_version(&quot;doParallel&quot;, version = &quot;1.0.17&quot;) remotes::install_version(&quot;RColorBrewer&quot;, version = &quot;1.1-3&quot;) remotes::install_version(&quot;gelnet&quot;, version = &quot;1.2.1&quot;) remotes::install_version(&quot;ggplot2&quot;, version = &quot;3.4.4&quot;) remotes::install_version(&quot;parallelDist&quot;, version = &quot;0.2.6&quot;) remotes::install_version(&quot;patchwork&quot;, version = &quot;1.1.3&quot;) remotes::install_version(&quot;markdown&quot;, version = &quot;1.10&quot;) remotes::install_version(&quot;kableExtra&quot;, version = &quot;1.3.4&quot;) remotes::install_version(&quot;transport&quot;, version = &quot;0.14-6&quot;) install required packages from BiocManager(Give every “Proceed?” a “y”) conda install -c bioconda bioconductor-monocle=2.28.0 conda install -c bioconda bioconductor-slingshot=2.8.0 conda install -c bioconda bioconductor-GSVA=1.48.2 conda install -c bioconda bioconductor-limma=3.56.2 conda install -c bioconda bioconductor-org.Mm.eg.db=3.17.0 conda install -c bioconda bioconductor-org.Hs.eg.db=3.17.0 conda install -c bioconda bioconductor-scran=1.28.1 conda install -c bioconda bioconductor-AUCell=1.22.0 conda install -c bioconda bioconductor-RcisTarget=1.20.0 conda install -c bioconda bioconductor-GENIE3=1.24.0 conda install -c bioconda bioconductor-clusterProfiler=4.8.3 conda install -c bioconda bioconductor-biomaRt=2.56.1 install required packages from GitHub tips: Sometimes network connection issues may occur, resulting in an error message indicating that GitHub cannot be connected. Please try installing again when the network conditions improve. Usage limitations: Sometimes an API rate limit error occurs, and a GitHub token is needed to provide the GitHub API rate limit. The steps to resolve this are as follows: Register for an account or log in to an existing account on the GitHub website. Then click on your profile picture in the top right corner, go to the dropdown menu and select “Settings.” Next, find “Developer settings” and click on it, then find “Personal access tokens (classic).” Click on it, then click “Create new token (classic).” Create a new token by first naming it anything you like. Then choose the expiration time for the token. Finally, check the “repo” box; the token will be used to download code repositories from GitHub. Click “Generate token.” Copy the generated token password. After that, set the token in the environment variable in R. Since we are using conda, enter R by typing R in the terminal. Then, enter the command: usethis::edit_r_environ(). This will open a file. Press the i key to edit. Paste the token you copied into the code area as follows: GITHUB_TOKEN=“your_token”. Then press Esc, type :wq! (force save). After that, you need to exit Linux and re-enter R. Close and reopen the terminal to apply the environment variable. Reopen Linux, activate the conda environment, and enter R again. R: devtools::install_github(&quot;jinworks/CellChat&quot;) devtools::install_github(&quot;aertslab/SCENIC&quot;) devtools::install_github(&quot;pzhulab/abcCellmap&quot;) devtools::install_github(&quot;navinlabcode/copykat&quot;) remotes::install_github(&#39;chris-mcginnis-ucsf/DoubletFinder&#39;) remotes::install_github(&quot;mojaveazure/seurat-disk&quot;) conda: conda install -c bioconda r-velocyto.r=0.6 Installed R packages with version Bioconductor 3.18 (BiocManager 1.30.23) Devtools 2.4.5 Matrix 1.6-5 shiny 1.7.5 textshaping 0.3.6 shinyjs 2.1.0 Seurat 4.3.0.1 phateR 1.0.7 DoubletFinder 2.0.4 monocle 2.28.0 slingshot 2.8.0 GSVA 1.48.2 #原1.48.3 limma 3.56.2 plyr 1.8.8 dplyr 1.1.2 org.Mm.eg.db 3.17.0 org.Hs.eg.db 3.17.0 CellChat 2.1.2 #原1.6.1 velocyto.R 0.6 SeuratWrappers 0.3.1 stringr 1.5.1 #原1.5.0 scran 1.28.1 #原1.28.2 ggpubr 0.6.0 viridis 0.6.4 pheatmap 1.0.12 parallel 4.3.3 reticulate 1.38.0 #原1.31 SCENIC 1.3.1 feather 0.3.5 AUCell 1.22.0 RcisTarget 1.20.0 foreach 1.5.2 doParallel 1.0.17 clusterProfiler 4.8.1 #原4.8.3 RColorBrewer 1.1-3 Rfast2 0.1.5.1 SeuratDisk 0.0.0.9021 #原0.0.0.9020 abcCellmap 0.1.0 biomaRt 2.56.1 copykat 1.1.0 gelnet 1.2.1 ggplot2 3.4.4 parallelDist 0.2.6 patchwork 1.1.3 markdown 1.10 GENIE3 1.24.0 2.3 Install required Python-packages upgrade pip and set mirrors python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip config set global.extra-index-url http://mirrors.aliyun.com/pypi/simple/ install required packages pip install numpy==1.23.5 pip install pandas==2.2.2 pip install matplotlib==3.5.2 pip install scvelo==0.2.5 pip install arboreto==0.1.6 pip install pot==0.9.1 pip install anndata==0.9.2 pip install scanpy==1.9.4 pip install scipy==1.11.2 pip install seaborn==0.12.2 pip install commot==0.0.3 pip install scvi-tools==1.0.3 pip install cell2location==0.1.3 #import cell2location:2 warnings pip install phate==1.0.11 pip install jax==0.4.20 pip install jaxlib==0.4.20 2.4 Install HemaScopeR devtools::install_github(repo=&quot;ZhenyiWangTHU/HemaScopeR&quot;, dep = FALSE) "],["integrated-scrna-seq-pipeline.html", "3 Integrated scRNA-seq pipeline", " 3 Integrated scRNA-seq pipeline Load the R packages. # sc libraries library(Seurat) library(phateR) library(DoubletFinder) library(monocle) library(slingshot) library(URD) library(GSVA) library(limma) library(plyr) library(dplyr) library(org.Mm.eg.db) library(org.Hs.eg.db) library(CellChat) library(velocyto.R) library(SeuratWrappers) library(stringr) library(scran) library(ggpubr) library(viridis) library(pheatmap) library(parallel) library(reticulate) library(SCENIC) library(feather) library(AUCell) library(RcisTarget) library(Matrix) library(foreach) library(doParallel) library(clusterProfiler) library(OpenXGR) # st libraries library(RColorBrewer) library(Rfast2) library(SeuratDisk) library(abcCellmap) library(biomaRt) library(copykat) library(gelnet) library(ggplot2) library(parallelDist) library(patchwork) library(markdown) # getpot library(getopt) library(tools) # HemaScopeR library(HemaScopeR) Run the integrated scRNA-seq pipeline. scRNASeq_10x_pipeline( # input and output input.data.dirs = c(&#39;./SRR7881399/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881400/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881401/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881402/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881403/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881404/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881405/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881406/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881407/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881408/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881409/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881410/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881411/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881412/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881413/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881414/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881415/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881416/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881417/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881418/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881419/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881420/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881421/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881422/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881423/outs/filtered_feature_bc_matrix&#39;), project.names = c( &#39;SRR7881399&#39;, &#39;SRR7881400&#39;, &#39;SRR7881401&#39;, &#39;SRR7881402&#39;, &#39;SRR7881403&#39;, &#39;SRR7881404&#39;, &#39;SRR7881405&#39;, &#39;SRR7881406&#39;, &#39;SRR7881407&#39;, &#39;SRR7881408&#39;, &#39;SRR7881409&#39;, &#39;SRR7881410&#39;, &#39;SRR7881411&#39;, &#39;SRR7881412&#39;, &#39;SRR7881413&#39;, &#39;SRR7881414&#39;, &#39;SRR7881415&#39;, &#39;SRR7881416&#39;, &#39;SRR7881417&#39;, &#39;SRR7881418&#39;, &#39;SRR7881419&#39;, &#39;SRR7881420&#39;, &#39;SRR7881421&#39;, &#39;SRR7881422&#39;, &#39;SRR7881423&#39;), output.dir = &#39;./output/&#39;, pythonPath = &#39;/home/anaconda3/envs/HemaScopeR/bin/python&#39;, # quality control and preprocessing gene.column = 2, min.cells = 10, min.feature = 200, mt.pattern = &#39;^MT-&#39;, nFeature_RNA.limit = 200, percent.mt.limit = 20, scale.factor = 10000, nfeatures = 3000, ndims = 50, vars.to.regress = NULL, PCs = 1:35, resolution = 0.4, n.neighbors = 50, # remove doublets doublet.percentage = 0.04, doublerFinderwraper.PCs = 1:20, doublerFinderwraper.pN = 0.25, doublerFinderwraper.pK = 0.1, # phateR phate.knn = 50, phate.npca = 20, phate.t = 10, phate.ndim = 2, min.pct = 0.25, logfc.threshold = 0.25, # visualization ViolinPlot.cellTypeOrders = as.character(1:22), ViolinPlot.cellTypeColors = NULL, Org = &#39;hsa&#39;, loom.files.path = c( &#39;./SRR7881399/velocyto/SRR7881399.loom&#39;, &#39;./SRR7881400/velocyto/SRR7881400.loom&#39;, &#39;./SRR7881401/velocyto/SRR7881401.loom&#39;, &#39;./SRR7881402/velocyto/SRR7881402.loom&#39;, &#39;./SRR7881403/velocyto/SRR7881403.loom&#39;, &#39;./SRR7881404/velocyto/SRR7881404.loom&#39;, &#39;./SRR7881405/velocyto/SRR7881405.loom&#39;, &#39;./SRR7881406/velocyto/SRR7881406.loom&#39;, &#39;./SRR7881407/velocyto/SRR7881407.loom&#39;, &#39;./SRR7881408/velocyto/SRR7881408.loom&#39;, &#39;./SRR7881409/velocyto/SRR7881409.loom&#39;, &#39;./SRR7881410/velocyto/SRR7881410.loom&#39;, &#39;./SRR7881411/velocyto/SRR7881411.loom&#39;, &#39;./SRR7881412/velocyto/SRR7881412.loom&#39;, &#39;./SRR7881413/velocyto/SRR7881413.loom&#39;, &#39;./SRR7881414/velocyto/SRR7881414.loom&#39;, &#39;./SRR7881415/velocyto/SRR7881415.loom&#39;, &#39;./SRR7881416/velocyto/SRR7881416.loom&#39;, &#39;./SRR7881417/velocyto/SRR7881417.loom&#39;, &#39;./SRR7881418/velocyto/SRR7881418.loom&#39;, &#39;./SRR7881419/velocyto/SRR7881419.loom&#39;, &#39;./SRR7881420/velocyto/SRR7881420.loom&#39;, &#39;./SRR7881421/velocyto/SRR7881421.loom&#39;, &#39;./SRR7881422/velocyto/SRR7881422.loom&#39;, &#39;./SRR7881423/velocyto/SRR7881423.loom&#39;), # cell cycle cellcycleCutoff = NULL, # cell chat sorting = FALSE, ncores = 10, # Verbose = FALSE, # activeEachStep Whether_load_previous_results = FALSE, Step1_Input_Data = TRUE, Step1_Input_Data.type = &#39;cellranger-count&#39;, Step2_Quality_Control = TRUE, Step2_Quality_Control.RemoveBatches = TRUE, Step2_Quality_Control.RemoveDoublets = TRUE, Step3_Clustering = TRUE, Step4_Identify_Cell_Types = TRUE, Step4_Use_Which_Labels = &#39;clustering&#39;, Step4_Cluster_Labels = NULL, Step4_Changed_Labels = NULL, Step4_run_sc_CNV = TRUE, Step5_Visualization = TRUE, Step6_Find_DEGs = TRUE, Step7_Assign_Cell_Cycle = TRUE, Step8_Calculate_Heterogeneity = TRUE, Step9_Violin_Plot_for_Marker_Genes = TRUE, Step10_Calculate_Lineage_Scores = TRUE, Step11_GSVA = TRUE, Step11_GSVA.identify.cellType.features=TRUE, Step11_GSVA.identify.diff.features=FALSE, Step11_GSVA.comparison.design=NULL, Step12_Construct_Trajectories = TRUE, Step12_Construct_Trajectories.clusters = c(&#39;3&#39;,&#39;6&#39;,&#39;9&#39;,&#39;10&#39;,&#39;11&#39;,&#39;14&#39;,&#39;15&#39;,&#39;19&#39;), Step12_Construct_Trajectories.monocle = TRUE, Step12_Construct_Trajectories.slingshot = TRUE, Step12_Construct_Trajectories.scVelo = TRUE, Step13_TF_Analysis = TRUE, Step14_Cell_Cell_Interaction = TRUE, Step15_Generate_the_Report = TRUE ) "],["step-by-step-scrna-seq-pipeline.html", "4 Step-by-step scRNA-seq Pipeline 4.1 Step 1. Load the R packages and the input data 4.2 Step 2. Quality Control 4.3 Step 3. Clustering 4.4 Step 4. Identify Cell Types 4.5 Step 5. Visualization 4.6 Step 6. Find DEGs 4.7 Step 7. Assign Cell Cycles 4.8 Step 8. Calculate Heterogeneity 4.9 Step 9. Violin Plot for Marker Genes 4.10 Step 10. Calculate Lineage Scores 4.11 Step 11. GSVA 4.12 Step 12. Construct Trajectories 4.13 Step 13. TF Analysis 4.14 Step 14. Cell-Cell Interaction", " 4 Step-by-step scRNA-seq Pipeline 4.1 Step 1. Load the R packages and the input data Load the R packages. # sc libraries library(Seurat) library(phateR) library(DoubletFinder) library(monocle) library(slingshot) library(URD) library(GSVA) library(limma) library(plyr) library(dplyr) library(org.Mm.eg.db) library(org.Hs.eg.db) library(CellChat) library(velocyto.R) library(SeuratWrappers) library(stringr) library(scran) library(ggpubr) library(viridis) library(pheatmap) library(parallel) library(reticulate) library(SCENIC) library(feather) library(AUCell) library(RcisTarget) library(Matrix) library(foreach) library(doParallel) library(clusterProfiler) library(OpenXGR) # st libraries library(RColorBrewer) library(Rfast2) library(SeuratDisk) library(abcCellmap) library(biomaRt) library(copykat) library(gelnet) library(ggplot2) library(parallelDist) library(patchwork) library(markdown) # getpot library(getopt) library(tools) # HemaScopeR library(HemaScopeR) Set the paths for the input data, the output results, and the Python installation. input.data.dirs = c(&#39;./SRR7881399/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881400/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881401/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881402/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881403/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881404/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881405/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881406/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881407/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881408/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881409/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881410/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881411/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881412/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881413/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881414/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881415/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881416/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881417/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881418/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881419/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881420/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881421/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881422/outs/filtered_feature_bc_matrix&#39;, &#39;./SRR7881423/outs/filtered_feature_bc_matrix&#39;) output.dir = &#39;./output/&#39; pythonPath = &#39;/home/anaconda3/envs/HemaScopeR/bin/python&#39; Set the parameters for loading the data sets. project.names = c(&#39;SRR7881399&#39;, &#39;SRR7881400&#39;, &#39;SRR7881401&#39;, &#39;SRR7881402&#39;, &#39;SRR7881403&#39;, &#39;SRR7881404&#39;, &#39;SRR7881405&#39;, &#39;SRR7881406&#39;, &#39;SRR7881407&#39;, &#39;SRR7881408&#39;, &#39;SRR7881409&#39;, &#39;SRR7881410&#39;, &#39;SRR7881411&#39;, &#39;SRR7881412&#39;, &#39;SRR7881413&#39;, &#39;SRR7881414&#39;, &#39;SRR7881415&#39;, &#39;SRR7881416&#39;, &#39;SRR7881417&#39;, &#39;SRR7881418&#39;, &#39;SRR7881419&#39;, &#39;SRR7881420&#39;, &#39;SRR7881421&#39;, &#39;SRR7881422&#39;, &#39;SRR7881423&#39;) gene.column = 2 min.cells = 10 min.feature = 200 mt.pattern = &#39;^MT-&#39; Step1_Input_Data.type = &#39;cellranger-count&#39; Create folders for saving the results of HemaScopeR analysis. wdir &lt;- getwd() if(is.null(pythonPath)==FALSE){ reticulate::use_python(pythonPath) }else{print(&#39;Please set the path of Python.&#39;)} if (!file.exists(paste0(output.dir, &#39;/HemaScopeR_results/&#39;))) { dir.create(paste0(output.dir, &#39;/HemaScopeR_results/&#39;)) } output.dir &lt;- paste0(output.dir,&#39;/HemaScopeR_results/&#39;) if (!file.exists(paste0(output.dir, &#39;/RDSfiles/&#39;))) { dir.create(paste0(output.dir, &#39;/RDSfiles/&#39;)) } previous_results_path &lt;- paste0(output.dir, &#39;/RDSfiles/&#39;) # if (Whether_load_previous_results) { # print(&#39;Loading the previous results...&#39;) # Load_previous_results(previous_results_path = previous_results_path) # } # Step1. Input data----------------------------------------------------------------------------- print(&#39;Step1. Input data.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step1.Input_data/&#39;))) { dir.create(paste0(output.dir, &#39;/Step1.Input_data/&#39;)) } Load the data sets. file.copy(from = input.data.dirs, to = paste0(output.dir,&#39;/Step1.Input_data/&#39;), recursive = TRUE) if(Step1_Input_Data.type == &#39;cellranger-count&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_data.temp &lt;- Read10X(data.dir = input.data.dirs[i], gene.column = gene.column) sc_object.temp &lt;- CreateSeuratObject(counts = sc_data.temp, project = project.names[i], min.cells = min.cells, min.feature = min.feature) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp)} }else{ sc_data &lt;- Read10X(data.dir = input.data.dirs, gene.column = gene.column) sc_object &lt;- CreateSeuratObject(counts = sc_data, project = project.names, min.cells = min.cells, min.feature = min.feature) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else if(Step1_Input_Data.type == &#39;Seurat&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_object.temp &lt;- readRDS(input.data.dirs[i]) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp) } }else{ sc_object &lt;- readRDS(input.data.dirs) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else if(Step1_Input_Data.type == &#39;Matrix&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_data.temp &lt;- readRDS(input.data.dirs[i]) sc_object.temp &lt;- CreateSeuratObject(counts = sc_data.temp, project = project.names[i], min.cells = min.cells, min.feature = min.feature) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp)} }else{ sc_data &lt;- readRDS(input.data.dirs) sc_object &lt;- CreateSeuratObject(counts = sc_data, project = project.names, min.cells = min.cells, min.feature = min.feature) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else{ stop(&#39;Please input data generated by the cellranger-count software, or a Seurat object, or a gene expression matrix. HemaScopeR does not support other formats of input data.&#39;) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.2 Step 2. Quality Control Set the parameters for quality control. # quality control and preprocessing nFeature_RNA.limit = 200 percent.mt.limit = 20 scale.factor = 10000 nfeatures = 3000 ndims = 50 vars.to.regress = NULL PCs = 1:35 resolution = 0.4 n.neighbors = 50 # remove doublets doublet.percentage = 0.04 doublerFinderwraper.PCs = 1:20 doublerFinderwraper.pN = 0.25 doublerFinderwraper.pK = 0.1 Step2_Quality_Control.RemoveBatches = TRUE Step2_Quality_Control.RemoveDoublets = TRUE Create a folder for saving the results of quality control. print(&#39;Step2. Quality control.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step2.Quality_control/&#39;))) { dir.create(paste0(output.dir, &#39;/Step2.Quality_control/&#39;)) } Run the quality control process. if(length(input.data.dirs) &gt; 1){ # preprocess and quality control for multiple scRNA-Seq data sets sc_object &lt;- QC_multiple_scRNASeq(seuratObjects = input.data.list, datasetID = project.names, output.dir = paste0(output.dir,&#39;/Step2.Quality_control/&#39;), Step2_Quality_Control.RemoveBatches = Step2_Quality_Control.RemoveBatches, Step2_Quality_Control.RemoveDoublets = Step2_Quality_Control.RemoveDoublets, nFeature_RNA.limit = nFeature_RNA.limit, percent.mt.limit = percent.mt.limit, scale.factor = scale.factor, nfeatures = nfeatures, ndims = ndims, vars.to.regress = vars.to.regress, PCs = PCs, resolution = resolution, n.neighbors = n.neighbors, percentage = doublet.percentage, doublerFinderwraper.PCs = doublerFinderwraper.PCs, doublerFinderwraper.pN = doublerFinderwraper.pN, doublerFinderwraper.pK = doublerFinderwraper.pK ) }else{ # preprocess and quality control for single scRNA-Seq data set sc_object &lt;- QC_single_scRNASeq(sc_object = sc_object, datasetID = project.names, output.dir = paste0(output.dir,&#39;/Step2.Quality_control/&#39;), Step2_Quality_Control.RemoveDoublets = Step2_Quality_Control.RemoveDoublets, nFeature_RNA.limit = nFeature_RNA.limit, percent.mt.limit = percent.mt.limit, scale.factor = scale.factor, nfeatures = nfeatures, vars.to.regress = vars.to.regress, ndims = ndims, PCs = PCs, resolution = resolution, n.neighbors = n.neighbors, percentage = doublet.percentage, doublerFinderwraper.PCs = doublerFinderwraper.PCs, doublerFinderwraper.pN = doublerFinderwraper.pN, doublerFinderwraper.pK = doublerFinderwraper.pK) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.3 Step 3. Clustering Set the parameters for clustering. PCs = 1:35 resolution = 0.4 n.neighbors = 50 Create a folder for saving the results of Louvain clustering. print(&#39;Step3. Clustering.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step3.Clustering/&#39;))) { dir.create(paste0(output.dir, &#39;/Step3.Clustering/&#39;)) } Run Louvian clustering. if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){graph.name &lt;- &#39;integrated_snn&#39;}else{graph.name &lt;- &#39;RNA_snn&#39;} sc_object &lt;- FindNeighbors(sc_object, dims = PCs, k.param = n.neighbors, force.recalc = TRUE) sc_object &lt;- FindClusters(sc_object, resolution = resolution, graph.name = graph.name) sc_object@meta.data$seurat_clusters &lt;- as.character(as.numeric(sc_object@meta.data$seurat_clusters)) # plot clustering pdf(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;tsne_cluster.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() pdf(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;umap_cluster.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;tsne_cluster.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;umap_cluster.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.4 Step 4. Identify Cell Types Set the path for the database. databasePath = &quot;~/HemaScopeR/database/&quot; Set the parameters for cell type identification. Step4_Use_Which_Labels = &#39;clustering&#39; Step4_Cluster_Labels = NULL Step4_Changed_Labels = NULL Org = &#39;hsa&#39; ncores = 10 Create a folder for saving the results of cell type identification. print(&#39;Step4. Identify cell types automatically.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;))) { dir.create(paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) } Run the cell type identification process and the copy number variation (CNV) analysis. sc_object &lt;- run_cell_annotation(object = sc_object, assay = &#39;RNA&#39;, species = Org, output.dir = paste0(output.dir,&#39;/Step4.Identify_Cell_Types/&#39;)) if(Org == &#39;hsa&#39;){ load(paste0(databasePath,&quot;/HematoMap.reference.rdata&quot;)) if(length(intersect(rownames(HematoMap.reference), rownames(sc_object))) &lt; 1000){ HematoMap.reference &lt;- RenameGenesSeurat(obj = HematoMap.reference, newnames = toupper(rownames(HematoMap.reference)), gene.use = rownames(HematoMap.reference), de.assay = &quot;RNA&quot;, lassays = &quot;RNA&quot;) } if(sc_object@active.assay == &#39;integrated&#39;){ DefaultAssay(sc_object) &lt;- &#39;RNA&#39; sc_object &lt;- mapDataToRef(ref_object = HematoMap.reference, ref_labels = HematoMap.reference@meta.data$CellType, query_object = sc_object, PCs = PCs, output.dir = paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ sc_object &lt;- mapDataToRef(ref_object = HematoMap.reference, ref_labels = HematoMap.reference@meta.data$CellType, query_object = sc_object, PCs = PCs, output.dir = paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) } } Set the cell labels. # set the cell labels if(Step4_Use_Which_Labels == &#39;clustering&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$seurat_clusters Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.1&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$Seurat.RNACluster Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.2&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$scmap.RNACluster Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.3&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$Seurat.Immunophenotype Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.4&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$scmap.Immunophenotype Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;HematoMap&#39;){ if(Org == &#39;hsa&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$predicted.id Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else{print(&quot;&#39;HematoMap&#39; is only applicable to human data (&#39;Org&#39; = &#39;hsa&#39;).&quot;)} }else if(Step4_Use_Which_Labels == &#39;changeLabels&#39;){ if (!is.null(Step4_Cluster_Labels) &amp;&amp; !is.null(Step4_Changed_Labels) &amp;&amp; length(Step4_Cluster_Labels) == length(Step4_Changed_Labels)){ sc_object@meta.data$selectLabels &lt;- plyr::mapvalues(sc_object@meta.data$seurat_clusters, from = as.character(Step4_Cluster_Labels), to = as.character(Step4_Changed_Labels), warn_missing = FALSE) Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else{ print(&quot;Please input the &#39;Step4_Cluster_Labels&#39; parameter as Seurat clustering labels, and the &#39;Step4_Changed_Labels&#39; parameter as new labels. Please note that these two parameters should be of equal length.&quot;) } }else{ print(&#39;Please set the &quot;Step4_Use_Which_Labels&quot; parameter as &quot;clustering&quot;, &quot;abcCellmap.1&quot;, &quot;abcCellmap.2&quot;, &quot;HematoMap&quot; or &quot;changeLabels&quot;.&#39;) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Run the CNV analysis. sc_CNV(sc_object=sc_object, save_path=paste0(output.dir,&#39;/Step4.Identify_Cell_Types/&#39;), assay = &#39;RNA&#39;, LOW.DR = 0.05, UP.DR = 0.1, win.size = 25, distance = &quot;euclidean&quot;, genome = NULL, n.cores = ncores, species = Org) 4.5 Step 5. Visualization Create a folder for saving the visualization results. print(&#39;Step5. Visualization.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step5.Visualization/&#39;))) { dir.create(paste0(output.dir, &#39;/Step5.Visualization/&#39;)) } The statistical results for the numbers and proportions of cell groups. # statistical results cells_labels &lt;- as.data.frame(cbind(rownames(sc_object@meta.data), as.character(sc_object@meta.data$selectLabels))) colnames(cells_labels) &lt;- c(&#39;cell_id&#39;, &#39;cluster_id&#39;) cluster_counts &lt;- cells_labels %&gt;% group_by(cluster_id) %&gt;% summarise(count = n()) total_cells &lt;- nrow(cells_labels) cluster_counts &lt;- cluster_counts %&gt;% mutate(proportion = count / total_cells) cluster_counts &lt;- as.data.frame(cluster_counts) cluster_counts$percentages &lt;- scales::percent(cluster_counts$proportion, accuracy = 0.1) cluster_counts &lt;- cluster_counts[,-which(colnames(cluster_counts)==&#39;proportion&#39;)] cluster_counts$cluster_id_count_percentages &lt;- paste(cluster_counts$cluster_id, &quot; (&quot;, cluster_counts$count, &#39; cells; &#39;, cluster_counts$percentages, &quot;)&quot;, sep=&#39;&#39;) cluster_counts &lt;- cluster_counts[order(cluster_counts$count, decreasing = TRUE),] cluster_counts &lt;- rbind(cluster_counts, c(&#39;Total&#39;, sum(cluster_counts$count), &#39;100%&#39;, &#39;all cells&#39;)) sc_object@meta.data$cluster_id_count_percentages &lt;- mapvalues(sc_object@meta.data$selectLabels, from=cluster_counts$cluster_id, to=cluster_counts$cluster_id_count_percentages, warn_missing=FALSE) colnames(sc_object@meta.data)[which(colnames(sc_object@meta.data) == &#39;cluster_id_count_percentages&#39;)] &lt;- paste(&#39;Total &#39;, nrow(sc_object@meta.data), &#39; cells&#39;, sep=&#39;&#39;) cluster_counts &lt;- cluster_counts[,-which(colnames(cluster_counts)==&#39;cluster_id_count_percentages&#39;)] colnames(cluster_counts) &lt;- c(&#39;Cell types&#39;, &#39;Cell counts&#39;, &#39;Percentages&#39;) # names(colorvector) &lt;- mapvalues(names(colorvector), # from=cluster_counts$cluster_id, # to=cluster_counts$cluster_id_count_percentages, # warn_missing=FALSE) write.csv(cluster_counts, file=paste(paste0(output.dir, &#39;/Step5.Visualization/&#39;), &#39;/cell types_cell counts_percentages.csv&#39;, sep=&#39;&#39;), quote=FALSE, row.names=FALSE) The UMAP visualization. pdf(paste(paste0(output.dir, &#39;/Step5.Visualization/&#39;), &#39;/cell types_cell counts_percentages_umap.pdf&#39;, sep=&#39;&#39;), width = 14, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = paste(&#39;Total &#39;, nrow(sc_object@meta.data), &#39; cells&#39;, sep=&#39;&#39;), label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Set the parameters for phateR. phate.knn = 50 phate.npca = 20 phate.t = 10 phate.ndim = 2 Run phateR for dimensional reduction and visualization. # run phateR if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object) &lt;- &#39;RNA&#39;} if(!is.null(pythonPath)){ run_phateR(sc_object = sc_object, output.dir = paste0(output.dir,&#39;/Step5.Visualization/&#39;), pythonPath = pythonPath, phate.knn = phate.knn, phate.npca = phate.npca, phate.t = phate.t, phate.ndim = phate.ndim) } Perform visualization using UMAP and TSNE. # plot cell types pdf(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;tsne cell types.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() pdf(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;umap cell types.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;tsne cell types.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;umap cell types.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.6 Step 6. Find DEGs Set the parameters for identifying differentially expressed genes. min.pct = 0.25 logfc.threshold = 0.25 Create a folder for the DEGs analysis. print(&#39;Step6. Find DEGs.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;))) { dir.create(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) } Identify DEGs using Wilcoxon Rank-Sum Test. sc_object.markers &lt;- FindAllMarkers(sc_object, only.pos = TRUE, min.pct = min.pct, logfc.threshold = logfc.threshold) write.csv(sc_object.markers, file = paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;),&#39;sc_object.markerGenes.csv&#39;), quote=FALSE) Set the parameters for GPTCelltype. your_openai_API_key = &#39;&#39; tissuename = &#39;human bone marrow&#39; gptmodel = &#39;gpt-3.5&#39; Use GPTCelltype to assist cell type annotation. GPT_annotation( marker.genes = sc_object.markers, your_openai_API_key = your_openai_API_key, tissuename = tissuename, gptmodel = gptmodel, output.dir = paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) Perform GO and KEGG enrichment. # GO enrichment if(Org==&#39;mmu&#39;){ OrgDb &lt;- &#39;org.Mm.eg.db&#39; }else if(Org==&#39;hsa&#39;){ OrgDb &lt;- &#39;org.Hs.eg.db&#39; }else{ stop(&quot;Org should be &#39;mmu&#39; or &#39;hsa&#39;.&quot;) } HemaScopeREnrichment(DEGs=sc_object.markers, OrgDb=OrgDb, output.dir=paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) sc_object.markers.top5 &lt;- sc_object.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 5, wt = avg_log2FC) pdf(paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;), &#39;sc_object_markerGenesTop5.pdf&#39;), width = 0.5*length(unique(sc_object.markers.top5$gene)), height = 0.5*length(unique(Idents(sc_object)))) print(DotPlot(sc_object, features = unique(sc_object.markers.top5$gene), cols=c(&quot;lightgrey&quot;,&#39;red&#39;))+theme(axis.text.x =element_text(angle = 45, vjust = 1, hjust = 1))) dev.off() png(paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;), &#39;sc_object_markerGenesTop5.png&#39;), width = 20*length(unique(sc_object.markers.top5$gene)), height = 30*length(unique(Idents(sc_object)))) print(DotPlot(sc_object, features = unique(sc_object.markers.top5$gene), cols=c(&quot;lightgrey&quot;,&#39;red&#39;))+theme(axis.text.x =element_text(angle = 45, vjust = 1, hjust = 1))) dev.off() Create a folder for saving the results of gene network analysis. if (!file.exists(paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;))) { dir.create(paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;)) } Perform gene network analysis. OpenXGR_SAG(sc_object.markers = sc_object.markers, output.dir = paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;), subnet.size = 10) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.7 Step 7. Assign Cell Cycles Create a folder for saving the results of cell cycle analysis. print(&#39;Step7. Assign cell cycles.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;))) { dir.create(paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;)) } Set the parameters for the cell cycle analysis. cellcycleCutoff = NULL Run the cell cycle analysis. datasets.before.batch.removal &lt;- readRDS(paste0(paste0(output.dir, &#39;/RDSfiles/&#39;),&#39;datasets.before.batch.removal.rds&#39;)) sc_object &lt;- cellCycle(sc_object=sc_object, counts_matrix = GetAssayData(object = datasets.before.batch.removal, slot = &quot;counts&quot;)%&gt;%as.matrix(), data_matrix = GetAssayData(object = datasets.before.batch.removal, slot = &quot;data&quot;)%&gt;%as.matrix(), cellcycleCutoff = cellcycleCutoff, cellTypeOrders = unique(sc_object@meta.data$selectLabels), output.dir=paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;), databasePath = databasePath, Org = Org) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.8 Step 8. Calculate Heterogeneity Create a folder for saving the results of heterogeneity calculation. print(&#39;Step8. Calculate heterogeneity.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;))) { dir.create(paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;)) } Run heterogeneity calculation process. expression_matrix &lt;- GetAssayData(object = datasets.before.batch.removal, slot = &quot;data&quot;)%&gt;%as.matrix() expression_matrix &lt;- expression_matrix[,rownames(sc_object@meta.data)] cell_types_groups &lt;- as.data.frame(cbind(sc_object@meta.data$selectLabels, sc_object@meta.data$datasetID)) colnames(cell_types_groups) &lt;- c(&#39;clusters&#39;, &#39;datasetID&#39;) if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } heterogeneity(expression_matrix = expression_matrix, cell_types_groups = cell_types_groups, cellTypeOrders = cellTypes_orders, output.dir = paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;)) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.9 Step 9. Violin Plot for Marker Genes Create a folder for saving the violin plots of marker genes. print(&#39;Step9. Violin plot for marker genes.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;))) { dir.create(paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;)) } Run violin plot visualization. if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object) &lt;- &#39;RNA&#39;} dataMatrix &lt;- GetAssayData(object = sc_object, slot = &quot;scale.data&quot;) if(is.null(marker.genes)&amp;(Org == &#39;mmu&#39;)){ # mpp genes are from &#39;The bone marrow microenvironment at single cell resolution&#39; # the other genes are from &#39;single cell characterization of haematopoietic progenitors and their trajectories in homeostasis and perturbed haematopoiesis&#39; # the aliases of these genes were changed in gecodeM16：Gpr64 -&gt; Adgrg2, Sdpr -&gt; Cavin2, Hbb-b1 -&gt; Hbb-bs, Sfpi1 -&gt; Spi1 HSC_lineage_signatures &lt;- c(&#39;Slamf1&#39;, &#39;Itga2b&#39;, &#39;Kit&#39;, &#39;Ly6a&#39;, &#39;Bmi1&#39;, &#39;Gata2&#39;, &#39;Hlf&#39;, &#39;Meis1&#39;, &#39;Mpl&#39;, &#39;Mcl1&#39;, &#39;Gfi1&#39;, &#39;Gfi1b&#39;, &#39;Hoxb5&#39;) Mpp_genes &lt;- c(&#39;Mki67&#39;, &#39;Mpo&#39;, &#39;Elane&#39;, &#39;Ctsg&#39;, &#39;Calr&#39;) Erythroid_lineage_signatures &lt;- c(&#39;Klf1&#39;, &#39;Gata1&#39;, &#39;Mpl&#39;, &#39;Epor&#39;, &#39;Vwf&#39;, &#39;Zfpm1&#39;, &#39;Fhl1&#39;, &#39;Adgrg2&#39;, &#39;Cavin2&#39;,&#39;Gypa&#39;, &#39;Tfrc&#39;, &#39;Hbb-bs&#39;, &#39;Hbb-y&#39;) Lymphoid_lineage_signatures &lt;- c(&#39;Tcf3&#39;, &#39;Ikzf1&#39;, &#39;Notch1&#39;, &#39;Flt3&#39;, &#39;Dntt&#39;, &#39;Btg2&#39;, &#39;Tcf7&#39;, &#39;Rag1&#39;, &#39;Ptprc&#39;, &#39;Ly6a&#39;, &#39;Blnk&#39;) Myeloid_lineage_signatures &lt;- c(&#39;Gfi1&#39;, &#39;Spi1&#39;, &#39;Mpo&#39;, &#39;Csf2rb&#39;, &#39;Csf1r&#39;, &#39;Gfi1b&#39;, &#39;Hk3&#39;, &#39;Csf2ra&#39;, &#39;Csf3r&#39;, &#39;Sp1&#39;, &#39;Fcgr3&#39;) marker.genes &lt;- c(HSC_lineage_signatures, Mpp_genes, Erythroid_lineage_signatures, Lymphoid_lineage_signatures, Myeloid_lineage_signatures) }else if(is.null(marker.genes)&amp;(Org == &#39;hsa&#39;)){ HSPCs_lineage_signatures &lt;- c(&#39;CD34&#39;,&#39;KIT&#39;,&#39;AVP&#39;,&#39;FLT3&#39;,&#39;MME&#39;,&#39;CD7&#39;,&#39;CD38&#39;,&#39;CSF1R&#39;,&#39;FCGR1A&#39;,&#39;MPO&#39;,&#39;ELANE&#39;,&#39;IL3RA&#39;) Myeloids_lineage_signatures &lt;- c(&#39;LYZ&#39;,&#39;CD36&#39;,&#39;MPO&#39;,&#39;FCGR1A&#39;,&#39;CD4&#39;,&#39;CD14&#39;,&#39;CD300E&#39;,&#39;ITGAX&#39;,&#39;FCGR3A&#39;,&#39;FLT3&#39;,&#39;AXL&#39;, &#39;SIGLEC6&#39;,&#39;CLEC4C&#39;,&#39;IRF4&#39;,&#39;LILRA4&#39;,&#39;IL3RA&#39;,&#39;IRF8&#39;,&#39;IRF7&#39;,&#39;XCR1&#39;,&#39;CD1C&#39;,&#39;THBD&#39;, &#39;MRC1&#39;,&#39;CD34&#39;,&#39;KIT&#39;,&#39;ITGA2B&#39;,&#39;PF4&#39;,&#39;CD9&#39;,&#39;ENG&#39;,&#39;KLF&#39;,&#39;TFRC&#39;) B_cells_lineage_signatures &lt;- c(&#39;CD79A&#39;,&#39;IGLL1&#39;,&#39;RAG1&#39;,&#39;RAG2&#39;,&#39;VPREB1&#39;,&#39;MME&#39;,&#39;IL7R&#39;,&#39;DNTT&#39;,&#39;MKI67&#39;,&#39;PCNA&#39;,&#39;TCL1A&#39;,&#39;MS4A1&#39;,&#39;IGHD&#39;,&#39;CD27&#39;,&#39;IGHG3&#39;) T_NK_cells_lineage_signatures &lt;- c(&#39;CD3D&#39;,&#39;CD3E&#39;,&#39;CD8A&#39;,&#39;CCR7&#39;,&#39;IL7R&#39;,&#39;SELL&#39;,&#39;KLRG1&#39;,&#39;CD27&#39;,&#39;GNLY&#39;, &#39;NKG7&#39;,&#39;PDCD1&#39;,&#39;TNFRSF9&#39;,&#39;LAG3&#39;,&#39;CD160&#39;,&#39;CD4&#39;,&#39;CD40LG&#39;,&#39;IL2RA&#39;, &#39;FOXP3&#39;,&#39;DUSP4&#39;,&#39;IL2RB&#39;,&#39;KLRF1&#39;,&#39;FCGR3A&#39;,&#39;NCAM1&#39;,&#39;XCL1&#39;,&#39;MKI67&#39;,&#39;PCNA&#39;,&#39;KLRF&#39;) marker.genes &lt;- c(HSPCs_lineage_signatures, Myeloids_lineage_signatures, B_cells_lineage_signatures, T_NK_cells_lineage_signatures) } if(is.null(ViolinPlot.cellTypeOrders)){ ViolinPlot.cellTypeOrders &lt;- unique(sc_object@meta.data$selectLabels) } if(is.null(ViolinPlot.cellTypeColors)){ ViolinPlot.cellTypeColors &lt;- viridis::viridis(length(unique(sc_object@meta.data$selectLabels))) } combinedViolinPlot(dataMatrix = dataMatrix, features = marker.genes, CellTypes = sc_object@meta.data$selectLabels, cellTypeOrders = ViolinPlot.cellTypeOrders, cellTypeColors = ViolinPlot.cellTypeColors, Org = Org, output.dir = paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;), databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.10 Step 10. Calculate Lineage Scores Create a folder for saving the results of lineage score calculation. print(&#39;Step10. Calculate lineage scores.&#39;) # we use normalized data here if (!file.exists(paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;))) { dir.create(paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;)) } Run lineage score calculation. if(is.null(lineage.genelist)&amp;is.null(lineage.names)&amp;(Org == &#39;mmu&#39;)){ lineage.genelist &lt;- c(list(HSC_lineage_signatures), list(Mpp_genes), list(Erythroid_lineage_signatures), list(Lymphoid_lineage_signatures), list(Myeloid_lineage_signatures)) lineage.names &lt;- c(&#39;HSC_lineage_signatures&#39;, &#39;Mpp_genes&#39;, &#39;Erythroid_lineage_signatures&#39;, &#39;Lymphoid_lineage_signatures&#39;, &#39;Myeloid_lineage_signatures&#39;) }else if(is.null(lineage.genelist)&amp;is.null(lineage.names)&amp;(Org == &#39;hsa&#39;)){ lineage.genelist &lt;- c(list(HSPCs_lineage_signatures), list(Myeloids_lineage_signatures), list(B_cells_lineage_signatures), list(T_NK_cells_lineage_signatures)) lineage.names &lt;- c(&#39;HSPCs_lineage_signatures&#39;, &#39;Myeloids_lineage_signatures&#39;, &#39;B_cells_lineage_signatures&#39;, &#39;T_NK_cells_lineage_signatures&#39;) } if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } lineageScores(expression_matrix = expression_matrix, cellTypes = sc_object@meta.data$selectLabels, cellTypes_orders = cellTypes_orders, cellTypes_colors = ViolinPlot.cellTypeColors, groups = sc_object@meta.data$datasetID, groups_orders = unique(sc_object@meta.data$datasetID), groups_colors = groups_colors, lineage.genelist = lineage.genelist, lineage.names = lineage.names, Org = Org, output.dir = paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;), databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.11 Step 11. GSVA Create a folder for saving the results of GSVA. print(&#39;Step11. GSVA.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step11.GSVA/&#39;))) { dir.create(paste0(output.dir, &#39;/Step11.GSVA/&#39;)) } Run GSVA. setwd(wdir) if(Org==&#39;mmu&#39;){ load(paste0(databasePath,&quot;/mouse_c2_v5p2.rdata&quot;)) GSVA.genelist &lt;- Mm.c2 assign(&#39;OrgDB&#39;, org.Mm.eg.db) }else if(Org==&#39;hsa&#39;){ load(paste0(databasePath,&quot;/human_c2_v5p2.rdata&quot;)) GSVA.genelist &lt;- Hs.c2 assign(&#39;OrgDB&#39;, org.Hs.eg.db) }else{ stop(&quot;Org should be &#39;mmu&#39; or &#39;hsa&#39;.&quot;) } if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } run_GSVA(sc_object = sc_object, GSVA.genelist = GSVA.genelist, GSVA.cellTypes = sc_object@meta.data$selectLabels, GSVA.cellTypes.orders = cellTypes_orders, GSVA.cellGroups = sc_object@meta.data$datasetID, GSVA.identify.cellType.features = Step11_GSVA.identify.cellType.features, GSVA.identify.diff.features = Step11_GSVA.identify.diff.features, GSVA.comparison.design = Step11_GSVA.comparison.design, OrgDB = OrgDB, output.dir = paste0(output.dir, &#39;/Step11.GSVA/&#39;)) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.12 Step 12. Construct Trajectories Load gene symbols and ensemble IDs. DefaultAssay(sc_object) &lt;- &#39;RNA&#39; countsSlot &lt;- GetAssayData(object = sc_object, slot = &quot;counts&quot;) gene_metadata &lt;- as.data.frame(rownames(countsSlot)) rownames(gene_metadata) &lt;- gene_metadata[,1] if(Org == &#39;mmu&#39;){ load(paste0(databasePath,&quot;/mouseGeneSymbolandEnsembleID.rdata&quot;)) gene_metadata $ ensembleID &lt;- mapvalues(x = gene_metadata[,1], from = mouseGeneSymbolandEnsembleID$geneName, to = mouseGeneSymbolandEnsembleID$ensemblIDNoDot, warn_missing = FALSE) }else if(Org == &#39;hsa&#39;){ load(paste0(databasePath,&quot;/humanGeneSymbolandEnsembleID.rdata&quot;)) gene_metadata $ ensembleID &lt;- mapvalues(x = gene_metadata[,1], from = humanGeneSymbolandEnsembleID$geneName, to = humanGeneSymbolandEnsembleID$ensemblIDNoDot, warn_missing = FALSE) } colnames(gene_metadata) &lt;- c(&#39;gene_short_name&#39;,&#39;ensembleID&#39;) Create folders for saving the results of trajectory construction. print(&#39;Step12. Construct trajectories.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;)) } Prepare the input data. if(is.null(Step12_Construct_Trajectories.clusters)){ sc_object.subset &lt;- sc_object countsSlot.subset &lt;- GetAssayData(object = sc_object.subset, slot = &quot;counts&quot;) }else{ sc_object.subset &lt;- subset(sc_object, subset = selectLabels %in% Step12_Construct_Trajectories.clusters) countsSlot.subset &lt;- GetAssayData(object = sc_object.subset, slot = &quot;counts&quot;) } Run monocle2. # monocle2 phenoData &lt;- sc_object.subset@meta.data featureData &lt;- gene_metadata run_monocle(cellData = countsSlot.subset, phenoData = phenoData, featureData = featureData, lowerDetectionLimit = 0.5, expressionFamily = VGAM::negbinomial.size(), cellTypes=&#39;selectLabels&#39;, monocle.orders=Step12_Construct_Trajectories.clusters, monocle.colors = ViolinPlot.cellTypeColors, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;)) Run slingshot. # slingshot if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object.subset) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object.subset) &lt;- &#39;RNA&#39;} run_slingshot(slingshot.PCAembeddings = Embeddings(sc_object.subset, reduction = &quot;pca&quot;)[, PCs], slingshot.cellTypes = sc_object.subset@meta.data$selectLabels, slingshot.start.clus = slingshot.start.clus, slingshot.end.clus = slingshot.end.clus, slingshot.colors = slingshot.colors, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;)) Run scVelo. # scVelo if((!is.null(loom.files.path))&amp;(!is.null(pythonPath))){ prepareDataForScvelo(sc_object = sc_object.subset, loom.files.path = loom.files.path, scvelo.reduction = &#39;pca&#39;, scvelo.column = &#39;selectLabels&#39;, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;)) reticulate::py_run_string(paste0(&quot;import os\\noutputDir = &#39;&quot;, output.dir, &quot;&#39;&quot;)) reticulate::py_run_file(file.path(system.file(package = &quot;HemaScopeR&quot;), &quot;python/sc_run_scvelo.py&quot;), convert = FALSE) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.13 Step 13. TF Analysis Create folders for saving the results of TF analysis. print(&#39;Step13. TF analysis.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step13.TF_analysis/&#39;))) { dir.create(paste0(output.dir, &#39;/Step13.TF_analysis/&#39;)) } Run SCENIC to perform TF analysis. run_SCENIC(countMatrix = countsSlot, cellTypes = sc_object@meta.data$selectLabels, datasetID = sc_object@meta.data$datasetID, cellTypes_colors = Step13_TF_Analysis.cellTypes_colors, cellTypes_orders = unique(sc_object@meta.data$selectLabels), groups_colors = Step13_TF_Analysis.groups_colors, groups_orders = unique(sc_object@meta.data$datasetID), Org = Org, output.dir = paste0(output.dir, &#39;/Step13.TF_analysis/&#39;), pythonPath = pythonPath, databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.14 Step 14. Cell-Cell Interaction Create folders for saving the results of cell-cell interaction analysis. print(&#39;Step14. Cell-cell interaction.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;))) { dir.create(paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;)) } Run CellChat to perform cell-cell interaction analysis. tempwd &lt;- getwd() run_CellChat(data.input=countsSlot, labels = sc_object@meta.data$selectLabels, cell.orders = ViolinPlot.cellTypeOrders, cell.colors = ViolinPlot.cellTypeColors, sample.names = rownames(sc_object@meta.data), Org = Org, sorting = sorting, output.dir = paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;)) setwd(tempwd) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } "],["stey-by-step-st-seq-pipeline.html", "5 Stey-by-step st-seq pipeline 5.1 Step 1. Data loading 5.2 Step 2. QC 5.3 Step 3. Clustering 5.4 Step 4. DEGs 5.5 Step 5. Spatially variable features 5.6 Step 6. Spatial interaction 5.7 Step 7. CNV analysis 5.8 Step 8. Deconvolution 5.9 Step 9. Cell cycle 5.10 Step 10. Niche analysis", " 5 Stey-by-step st-seq pipeline 5.1 Step 1. Data loading The st_Loading_Data function is designed for loading 10X Visium spatial transcriptomics data from Space Ranger. It will load data from input.data.dir and output it in the SeuratOjbect format. 5.1.1 Function arguments: input.data.dir: The directory where the input data is stored. output.dir: The directory where the processed output will be saved. If not specified, the output is saved in the current working directory. Default is ‘.’. sampleName: A string naming the sample. Default is ‘Hema_ST’. rds.file: A boolean indicating if the input data is in RDS file format rather than a typical results of Space Ranger. Default is FALSE. filename: The name of the file to be loaded if the data is not in RDS format. Default is “filtered_feature_bc_matrix.h5”. assay: The specific assay to apply to the data. Default is ‘Spatial’. slice: The image slice identifier for the spatial data. Default is ‘slice1’. filter.matrix: A boolean indicating whether to load filtered matrix. Default is TRUE. to.upper: A boolean indicating whether to convert feature names to upper form. Default is FALSE. 5.1.2 Funciton behavior: Directory Creation: The function first checks if the output.dir exists; if not, it creates it. RDS File Handling: If rds.file is TRUE, it reads the RDS file, ensuring the specified assay and slice are present in the Seurat object. Non-RDS File Handling: If rds.file is FALSE, it loads the data using Load10X_Spatial from Seurat. Saving the Object: Uses SaveH5Seurat and Convert to save the Seurat object in rds and h5ad formats. File Copying: Copies any necessary files (filter matrix, spatial image) to the output.dir. Return Value: Returns the processed Seurat object. 5.1.3 An example: st_obj &lt;- st_Loading_Data( input.data.dir = &#39;path/to/data&#39;, output.dir = &#39;.&#39;, sampleName = &#39;Hema_ST, rds.file = FALSE, filename = &#39;filtered_feature_bc_matrix.h5&#39;, assay = &#39;Spatial&#39;, slice = &#39;slice1&#39;, filter.matrix = TRUE, to.upper = FALSE ) 5.1.4 Outputs: Spatial transcriptome data in rds and h5ad formats 5.2 Step 2. QC The QC_Spatial function performs basic quality control on a SeuratObject containing 10X visium data and returns the filtered SeuratObject. It provides options to set thresholds for the number of genes, nUMI (unique molecular identifiers), and spots expressing each gene. It also allows for the removal of mitochondrial genes based on species. 5.2.1 Function arguments: st_obj: A SeuratObject of 10X visium data. output.dir: A character string specifying the path to store the results and figures. Default is the current working directory. min.gene: An integer representing the minimum number of genes detected in a spot. Default is 200. max.gene: An integer representing the maximum number of genes detected in a spot. Default is Inf (no upper limit). min.nUMI: An integer representing the minimum number of nUMI detected in a spot. Default is 500. max.nUMI: An integer representing the maximum number of nUMI detected in a spot. Default is Inf (no upper limit). min.spot: An integer representing the minimum number of spots expressing each gene. Default is 3. species: A character string representing the species of sample, either ‘human’ or ‘mouse’. bool.remove.mito: A boolean value indicating whether to remove mitochondrial genes. Default is TRUE. SpatialColors: A function that interpolates a set of given colors to create new color palettes and color ramps. Default is a color palette with reversed Spectral colors from RColorBrewer. 5.2.2 Function behavior: Plots and saves the spatial distribution of nUMI and nGene. Plots and saves violin plots for nUMI and nGene. Identifies and marks low-quality spots based on nUMI and nGene thresholds. Plots the spatial distribution of quality. Plots and saves a histogram for the number of spots expressing each gene. Plots the spatial distribution of mitochondrial genes. Saves the raw SeuratObject before filtering. Removes low-quality spots and genes with fewer occurrences. Optionally removes mitochondrial genes. Saves the filtered SeuratObject. Returns the filtered st_obj. 5.2.3 An example: st_obj &lt;- QC_Spatial( st_obj = st_obj, output.dir = &#39;.&#39;, min.gene = 200, min.nUMI = Inf, max.gene = 500, max.nUMI = Inf, min.spot = 3, species = &#39;human&#39;, bool.remove.mito = TRUE, SpatialColors = colorRampPalette(colors = rev(x = brewer.pal(n = 11, name = &quot;Spectral&quot;))) ) 5.2.4 Outputs: Figures showing the spatial distribution of nUMI and nGene. Violin plots of nUMI and nGene. Figures showing the quality. Histograms for the number of spots expressing each gene. Figures showing the spatial distribution of mitochondrial genes. Raw and filtered SeuratObject. 5.3 Step 3. Clustering The st_Clustering function is designed to perform clustering analysis on spatial transcriptomics data. It integrates several key steps including data normalization, dimensionality reduction, clustering, and visualization. The function saves the results and visualizations to output.dir. 5.3.1 Function arguments: st_obj: The input spatial transcriptomics seurat object that contains the data to be clustered. output.dir: The directory where the output files will be saved. Default is the current directory (‘.’). normalization.method: The method used for data normalization. Default is ‘SCTransform’. npcs: The number of principal components to use in PCA. Default is 50. pcs.used: The principal components to use for clustering. Default is the first 10 PCs (1:10). resolution: The resolution parameter for the clustering algorithm. Default is 0.8. verbose: A logical flag to print progress messages. Default is FALSE. 5.3.2 Function behavior: Data Normalization and PCA: Depending on the normalization.method, the function either uses SCTransform or a standard normalization method followed by scaling and variable feature detection. Performs PCA on the normalized data. Clustering and Dimensionality Reduction: Finds nearest neighbors using the specified principal components (pcs.used). Identifies clusters using the specified resolution. Performs UMAP and t-SNE for visualization of the clusters. Visualization: Generates spatial, UMAP, and t-SNE plots of the clusters with customized color schemes. Saves these plots as images in the specified directory. Saving Results: Saves the updated st_obj as an RDS file. Exports the metadata of st_obj to a CSV file. Return Value: Returns the updated st_obj containing the clustering results. 5.3.3 An example: st_obj &lt;- st_Clustering( st_obj = st_obj, output.dir = &#39;.&#39;, normalization.method = &#39;SCTransform&#39;, npcs = 50, pcs.used = 1:10, resolution = 0.8, verbose = FALSE ) 5.3.4 Outputs: Figures showing the results of clustering. SeuratObject in rds format. 5.4 Step 4. DEGs The st_Find_DEGs function is designed to identify differentially expressed genes (DEGs) in spatial transcriptomics data. It performs differential expression analysis based on clustering results, visualizes the top markers, and saves the results to output.dir. 5.4.1 Function arguments: st_obj: The input spatial transcriptomics object containing the data for DEG analysis. output.dir: The directory where output files will be saved. Default is the current directory (‘.’). ident.label: The metadata label used for identifying clusters. Default is 'seurat_clusters'. only.pos: A logical flag to include only positive markers. Default is TRUE. min.pct: The minimum fraction of cells expressing the gene in either cluster. Default is 0.25. logfc.threshold: The log fold change threshold for considering a gene differentially expressed. Default is 0.25. test.use: The statistical test to use for differential expression analysis. Default is 'wilcox'. verbose: A logical flag to print progress messages. Default is FALSE. 5.4.2 Function behavior: Set Identifiers: Sets the cluster identifiers in the spatial transcriptomics object (st_obj) based on the specified ident.label. Find Differentially Expressed Genes (DEGs): Performs differential expression analysis using the specified parameters (only.pos, min.pct, logfc.threshold, test.use). Top Marker Genes: Selects the top 5 marker genes for each cluster based on the highest average log fold change. Visualization: Generates a dot plot for the top DEGs and saves the plot as an image in the specified directory. Saving Results: Saves the DEG results as a CSV file. Return Value: Returns the data frame containing the identified DEGs. 5.4.3 An example: st.markers &lt;- st_Find_DEGs( st_obj = st_obj, output.dir = &#39;.&#39;, ident.label = &#39;seurat_clusters&#39;, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = &#39;wilcox&#39;, verbose = FALSE ) 5.4.4 Outputs: Dot plots showing markers. CSV file containing the information of markers. 5.5 Step 5. Spatially variable features The st_SpatiallyVariableFeatures function identifies and visualizes spatially variable features (SVFs) in spatial transcriptomics data. It integrates the identification of spatially variable features using a specified method, saves the results to a directory, and creates visualizations of the top spatially variable features. 5.5.1 Function arguments: st_obj: The input spatial transcriptomics object containing the data for analysis. output.dir: The directory where output files will be saved. Default is the current directory. assay: The assay to be used for finding spatially variable features. Default is 'SCT'. selection.method: The method used for selecting spatially variable features. Default is 'moransi'. n.top.show: The number of top spatially variable features to visualize. Default is 10. n.col: The number of columns for the visualization grid. Default is 5. verbose: A logical flag to print progress messages. Default is FALSE. 5.5.2 Function behavior: Identify Spatially Variable Features: Identifies spatially variable features using the specified method and assay. Suppresses warnings during the process. Save Metadata: Extracts metadata features and saves them as a CSV file in output.dir. Visualization: Selects the top n.top.show spatially variable features. Generates and saves a spatial feature plot of these features in the specified directory. Return Value: Returns the updated st_obj containing the identified spatially variable features. 5.5.3 An example: st_obj &lt;- st_SpatiallyVariableFeatures( st_obj = st_obj, output.dir = &#39;.&#39;, assay = st_obj@active.assay, selection.method = &#39;moransi&#39;, n.top.show = 10, n.col = 5, verbose = FALSE ) 5.5.4 Outputs: Figures showing SVFs. CSV file containing the information of SVFs. 5.6 Step 6. Spatial interaction The st_Interaction function is used to identify and visualize interactions between clusters based on spatial transcriptomics data. It utilizes Commot to analyze spatial interactions, identify pathway activities, and assess the strength and significance of interactions. 5.6.1 Function arguments: st_data_path: Path to the spatial transcriptomics data. metadata_path: Path to the metadata associated with the spatial transcriptomics data. library_id: Identifier for the spatial transcriptomics library. Default is 'Hema_ST'. label_key: Key in the metadata to identify cell clusters. Default is 'seurat_clusters'. save_path: The directory where output files will be saved. Default is the current directory. species: The species of the spatial transcriptomics data. Default is 'human'. signaling_type: Type of signaling interactions to consider. Default is 'Secreted Signaling'. database: Database to be used for the analysis. Default is 'CellChat'. min_cell_pct: Minimum percentage of cells to consider for interaction analysis. Default is 0.05. dis_thr: Distance threshold for defining interactions. Default is 500. n_permutations: Number of permutations for assessing significance. Default is 100. pythonPath: The path to the Python environment containing Commot to use for the analysis. Default is ‘.’. 5.6.2 Function behavior: Commot Analysis: Uses Commot to perform interaction analysis, identifying interactions within and between clusters. Visualization: Generates visualizations of pathway interactions and interactions between ligand-receptors (LRs) within and between clusters, and saves them in save_path. 5.6.3 An example: st_Interaction( st_data_path = &#39;path/to/data&#39;, metadata_path = &#39;path/to/metadata&#39;, library_id = &#39;Hema_ST&#39;, label_key = &#39;seurat_clusters&#39;, save_path = &#39;.&#39;, species = &#39;human&#39;, signaling_type = &#39;Secreted Signaling&#39;, database = &#39;CellChat&#39;, min_cell_pct = 0.05, dis_thr = 500, n_permutations = 100, pythonPath = &#39;path/to/python&#39; ) 5.6.4 Outputs: Dot plot showing pathway interaction between and within clusters. Dot plot showing LRs interaction between and within clusters. The information of each LR and pathway. 5.7 Step 7. CNV analysis The st_CNV function identifies and visualizes copy number variations (CNVs) in spatial transcriptomics data. It uses CopyKAT to perform the CNV analysis, saves the results, and generates visual representations of CNV states. 5.7.1 Function arguments: st_obj: The input spatial transcriptomics object containing the data for analysis. save_path: The directory where output files will be saved. assay: The assay to be used for CNV analysis. Default is 'Spatial'. LOW.DR: The lower threshold for the dropout rate in CopyKAT. Default is 0.05. UP.DR: The upper threshold for the dropout rate in CopyKAT. Default is 0.1. win.size: The window size for the CNV analysis. Default is 25. distance: The distance metric to be used for the analysis. Default is \"euclidean\". genome: The genome version to be used, ‘hg20’ or ‘mm10’. Default is \"hg20\". n.cores: The number of cores to be used for parallel processing. Default is 1. species: The species of the spatial transcriptomics data. Default is 'human'. 5.7.2 Function behavior: CopyKAT Analysis: Runs CopyKAT pipeline to perform CNV analysis using the provided parameters. Saving Results: Saves the CopyKAT results as an RDS file. Plotting: Generates plots of the CNV states and saves them in save_path. Updating Metadata: Updates the spatial transcriptomics object with CNV state metadata. Return Value: Returns the updated st_obj containing the CNV state information. 5.7.3 An example: st_obj &lt;- st_CNV( st_obj = st_obj, save_path = &#39;.&#39;, assay = &#39;Spatial&#39;, LOW.DR = 0.05, UP.DR = 0.1, win.size = 25, distance = &quot;euclidean&quot;, genome = &#39;hg20&#39;, n.cores = 1, species = &#39;human&#39; ) 5.7.4 Outputs: Figures showing the predicted CNV states. Figures showing the CNV heatmap. rds files of results of copykat. 5.8 Step 8. Deconvolution The st_Deconvolution function aims to perform spatial deconvolution analysis on spatial transcriptomics data to estimate the cell-type composition and abundance in different regions. The function utilizes cell2location to infer cell-type abundance and spatial distributions, allowing for the visualization and interpretation of spatially resolved cell populations within the tissue. 5.8.1 Function arguments: st.data.dir: Path to the spatial transcriptomics data. sc.h5ad.dir: Path to the single-cell RNA-seq data in h5ad format. Default is NULL. library_id: Identifier for the spatial transcriptomics library. Default is 'Hema_ST'. st_obj: Spatial transcriptomics object containing the data for analysis. Default is NULL. save_path: The directory where output files will be saved. Default is NULL. sc.labels.key: Key in the single-cell metadata to identify cell clusters. Default is 'seurat_clusters'. species: The species of the spatial transcriptomics data. Default is 'mouse'. sc.max.epoch: Maximum number of epochs used for single-cell deconvolution. Default is 1000. st.max.epoch: Maximum number of epochs used for spatial deconvolution. Default is 10000. use.gpu: Logical value indicating whether to use GPU for computation. Default is FALSE. use.Dataset: The dataset to be used for analysis, such as 'HematoMap' or 'LymphNode'. pythonPath: The path to the Python environment containing cell2location to use for the analysis. Default is ‘.’. 5.8.2 Function behavior: Deconvolution Analysis: Performs the spatial deconvolution analysis using the provided spatial transcriptomics and single-cell RNA-seq data. Post-Analysis Processing: Processes the deconvolution results and visualizes the spatial distribution of inferred cell types within the tissue. Returning Results: If a Seurat object is provided, the updated Seurat object with cell type information is returned. 5.8.3 An example: st_obj &lt;- st_Deconvolution( st.data.dir = &#39;path/to/data&#39;, library_id = &#39;Hema_ST&#39;, sc.h5ad.dir = NULL, st_obj = st_obj, save_path = &#39;.&#39;, sc.labels.key = &#39;seurat_clusters&#39;, species = &#39;human&#39;, sc.max.epoch = 1000, st.max.epoch = 10000, use.gpu = FALSE, use.Dataset = &#39;LymphNode&#39;, pythonPath = &#39;path/to/python&#39; ) 5.8.4 Outputs: Figures showing the predicted abundance of each cell-type. The parameters of trained cell2location model. 5.9 Step 9. Cell cycle The st_Cell_cycle function is used to assess the cell cycle phase scores in spatial transcriptomics data. It calculates S phase and G2M phase scores based on the expression of designated cell cycle-related genes and visualizes these scores in spatial and dimensionality-reduced plots. 5.9.1 Function arguments: st_obj: The input Seurat object containing the data for analysis. save_path: The directory where the output images will be saved. Default is the current directory. s.features: A list of genes associated with the S phase. Default is NULL (using genes from Seurat). g2m.features: A list of genes associated with the G2M phase. Default is NULL (using genes from Seurat). species: The species of the spatial transcriptomics data. Default is 'human'. FeatureColors.bi: A color palette for visualization. Default is a two-color ramp palette. 5.9.2 Function behavior: Gene Feature Assignment: Assigns S phase and G2M phase gene lists based on the specified species or provided input. Cell Cycle Scoring: Calculates the S phase and G2M phase scores in the data. Spatial Visualization: Generates spatial feature plots to visualize the S phase and G2M phase scores using the specified color palette and saves the plots as images. Dimensionality-Reduced Plot Visualization: If UMAP or tSNE dimensionality reduction is available in the st_obj, feature plots of the S phase and G2M phase scores are generated in the reduced space and saved as images. Return Value: Returns the updated st_obj containing the cell cycle phase scores. 5.9.3 An example: st_obj &lt;- st_Cell_cycle( st_obj = st_obj, save_path = &#39;.&#39;, s.features = NULL, g2m.features = NULL, species = &#39;human&#39;, FeatureColors.bi = colorRampPalette(colors = rev(x = brewer.pal(n = 11, name = &#39;RdYlBu&#39;))) ) 5.9.4 Outputs: Figures showing S scores. Figures showing S scores. 5.10 Step 10. Niche analysis The st_NicheAnalysis function is designed to perform niche analysis on spatial transcriptomics data, enabling the exploration of spatial niches or microenvironments within the tissue. The function encompasses co-occurrence analysis, niche clustering, and niche interaction analysis to uncover the spatial relationships and characteristics of different cell populations or features. 5.10.1 Function arguments: st_obj: The input SeuratObject containing the spatial transcriptomics data for analysis. features: A vector of features representing features (for example, cell types from deconvolution) for niche analysis. save_path: The directory where the analysis results and visualizations will be saved. Default is the current directory. coexistence.method: The method for co-occurrence analysis, accepting 'correlation' or 'Wasserstein'. Default is 'correlation'. kmeans.n: The number of clusters for niche clustering. Default is 4. st_data_path: A path containing the ‘spatial’ file and ‘filtered_feature_bc_matrix.h5’ file, required for niche interaction visualization. slice: The slice to be used for analysis. Default is 'slice1'. species: The species of the sample data. Default is 'mouse'. pythonPath: The path to the Python environment containing Commot to use for the analysis. Default is ‘.’. 5.10.2 Function behavior: Co-occurrence Score Calculation: Calculates the co-occurrence scores between the specified features using the chosen coexistence method (‘correlation’ or ‘Wasserstein’). Niche Clustering: Utilizes k-means clustering to identify distinct spatial niches based on the expression profiles of the selected features and visualizes the clustering results. Niche Interaction Visualization: If the st_data_path is provided, performs niche interaction visualization using Commot, which is based on the provided spatial transcriptomics data and generates visualizations of niche interactions within the tissue. Return Value: Returns the updated st_obj with niche analysis results and visualizations. 5.10.3 An example: tmp &lt;- read.csv(&#39;path/to/cell2loc_res.csv&#39;, row.names = 1) features &lt;- colnames(tmp) if(!all(features %in% names(st_obj@meta.data))){ common.barcodes &lt;- intersect(colnames(st_obj), rownames(tmp)) tmp &lt;- tmp[common.barcodes, ] st_obj &lt;- st_obj[, common.barcodes] st_obj &lt;- AddMetaData(st_obj, metadata = tmp) } st_obj &lt;- st_NicheAnalysis( st_obj, features = features, save_path = &#39;.&#39;, coexistence.method = &#39;correlation&#39;, kmeans.n = 4, st_data_path = &#39;path/to/data&#39;, slice = `slice1`, species = &#39;human&#39;, condaenv = &#39;path/to/python&#39; ) 5.10.4 Outputs: Figures showing the co-existence results. Figures showing the spatial distribution of each niche. Figures showing the composition of each niche. Figures showing the results of interactions using Commot. "]]
